<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lua Web Log Server</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@12.3.3/dist/gridstack.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    <style>
        body {
        }

        .card-body {
            background-color: #101112;
        }

        #log,
        #processed {
            white-space: pre;
            font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', 'Liberation Mono', 'Courier New', monospace;
        }
            #log > div {
                padding-left: 0.5em;
                padding-right: 0.5em;
            }

                #log > div:nth-child(even) {
                    background-color: #232425;
                }

                #log > div:nth-child(odd) {
                    background-color: #181a1b;
                }

                #log > div:hover {
                    background-color: #000000;
                }

        .source-filename {
            color: #8ecae6; /* Adjust as needed */
        }

        .source-line {
            color: #ffb703; /* Adjust as needed */
        }

        .source-other {
            color: #fb8500; /* Adjust as needed */
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="grid-stack">
            <div class="grid-stack-item" id="window-raw_log" gs-x="0" gs-y="0" gs-w="12" gs-h="8">
                <div class="grid-stack-item-content p-0">
                    <div class="card bg-dark text-light h-100 shadow border-secondary">
                        <div class="card-header d-flex align-items-center justify-content-between bg-secondary bg-gradient text-white py-2 px-3">
                            <span>Raw Log</span>
                            <div>
                                <button type="button" class="btn btn-sm btn-light me-1" title="Maximize"><i class="bi-arrows-fullscreen"></i></button>
                                <button type="button" class="btn btn-sm btn-danger" title="Minimize"><i class="bi bi-dash"></i></button>
                            </div>
                        </div>
                        <div class="card-body p-0" style="overflow:scroll;">
                            <div id="log"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="grid-stack-item" id="window-cy" gs-x="6" gs-y="0" gs-w="6" gs-h="8">
                <div class="grid-stack-item-content p-0">
                    <div class="card bg-dark text-light h-100 shadow border-secondary">
                        <div class="card-header d-flex align-items-center justify-content-between bg-secondary bg-gradient text-white py-2 px-3">
                            <span>Test</span>
                            <div>
                                <button type="button" class="btn btn-sm btn-light me-1" title="Maximize"><i class="bi-arrows-fullscreen"></i></button>
                                <button type="button" class="btn btn-sm btn-danger" title="Minimize"><i class="bi bi-dash"></i></button>
                            </div>
                        </div>
                        <div class="card-body p-2" style="overflow:scroll;">
                            <div id="cy" class="h-100"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="grid-stack-item" id="window-test" gs-x="6" gs-y="0" gs-w="6" gs-h="8">
                <div class="grid-stack-item-content p-0">
                    <div class="card bg-dark text-light h-100 shadow border-secondary">
                        <div class="card-header d-flex align-items-center justify-content-between bg-secondary bg-gradient text-white py-2 px-3">
                            <span>Test</span>
                            <div>
                                <button type="button" class="btn btn-sm btn-light me-1" title="Maximize"><i class="bi-arrows-fullscreen"></i></button>
                                <button type="button" class="btn btn-sm btn-danger" title="Minimize"><i class="bi bi-dash"></i></button>
                            </div>
                        </div>
                        <div class="card-body p-2" style="overflow:scroll;">
                            <div id="processed"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const cyDarkStyle = [
            {
                selector: 'node',
                style: {
                    'label': 'data(id)',
                    'background-color': '#fb8500',      // orange node
                    'color': '#fff',                    // node label text
                    'text-outline-width': 2,
                    'text-outline-color': '#232425',    // dark outline for contrast
                    'font-size': 16,
                    'border-width': 2,
                    'border-color': '#ffb703',
                    'width': 'data(radius)',
                    'height': 'data(radius)',
                    //'width': 3,
                    //'height': 3,
                }
            },
            {
                selector: 'node[isLocation]',
                style: {
                    'background-opacity': 0, // or 0 for fully transparent
                    //'border-opacity': 0.2,
                    'border-color': '#fff',
                    'border-style': 'dashed',
                }
            },
            {
                selector: 'node[isWaypoint]',
                style: {
                    'label': '',
                    //'display': 'none'
                    'width': 3,
                    'height': 3,
                }
            },
            {
                selector: 'edge',
                style: {
                    'label': '',
                    'color': '#8ecae6',                 // edge label text
                    'font-size': 12,
                    //'text-background-color': '#232425', // dark background for edge label
                    //'text-background-opacity': 1,
                    //'text-background-padding': 2,
                    'color': '#ffffff',
                    'text-outline-width': 2,
                    'text-outline-color': '#232425',
                    'line-color': '#8ecae6',            // cyan edge
                    'width': 3,
                    'target-arrow-shape': 'triangle',
                    'target-arrow-color': '#8ecae6',
                    'curve-style': 'bezier'
                }
            },
            {
                selector: 'edge[isTerminus]',
                style: {
                    //'target-arrow-shape': 'none'
                    'display': 'none'
                }
            },
            {
                selector: 'node:selected',
                style: {
                    'background-color': '#219ebc',      // blue highlight
                    'border-color': '#fff',
                    'border-width': 3
                }
            },
            {
                selector: 'edge.hover, edge:selected',
                style: {
                    'label': 'data(label)',
                    'line-color': '#ffb703',           // highlight color
                    'target-arrow-color': '#ffb703',
                    'z-index': 999,                    // bring to front
                    'color': '#fff',
                    'text-outline-width': 2,
                    //'text-outline-color': '#ffb703',
                    'text-outline-color': '#232425',
                    //'text-background-color': '#232425',
                    //'text-background-opacity': 1,
                    //'text-background-padding': 6
                }
            }
        ];

        document.addEventListener('DOMContentLoaded', function () {
            const grid = GridStack.init({
                cellHeight: 70,
                handle: '.card-header' // Only the header is draggable
            });

            // Minimize: collapse card-body and shrink grid item
            document.querySelectorAll('.btn[title="Minimize"]').forEach(btn => {
                btn.addEventListener('click', function () {
                    const gridItem = btn.closest('.grid-stack-item');
                    const card = gridItem.querySelector('.card');
                    const body = card.querySelector('.card-body');
                    const isMinimized = body.classList.toggle('d-none');
                    if (isMinimized) {
                        grid.update(gridItem, { h: 1 });
                    } else {
                        grid.update(gridItem, { h: 4 });
                    }
                });
            });

            // Maximize: expand to full grid width and restore card body
            document.querySelectorAll('.btn[title="Maximize"]').forEach(btn => {
                btn.addEventListener('click', function () {
                    const gridItem = btn.closest('.grid-stack-item');
                    const card = gridItem.querySelector('.card');
                    const body = card.querySelector('.card-body');
                    body.classList.remove('d-none');
                    grid.update(gridItem, {
                        x: 0,
                        y: 0,
                        w: grid.getColumn(),
                        h: 8 // or any large value you prefer
                    });
                });
            });
        });
    </script>

    <script>
        function ansiToHtml(text) {
            const ansi_up = new AnsiUp();
            return ansi_up.ansi_to_html(text);
        }
        function stripAnsi(text) {
            return text.replace(/\x1b\[[0-9;]*m/g, '');
        }
    </script>

    <script>
        function splitKeepRemainder(str, delimiter, count) {
            const parts = str.split(delimiter);
            if (parts.length <= count) return parts;
            const result = parts.slice(0, count - 1);
            result.push(parts.slice(count - 1).join(delimiter));
            return result;
        }

        function formatTimestamp(tsStr) {
            // Remove leading spaces and parse as float
            const seconds = parseFloat(tsStr.trim());
            if (isNaN(seconds)) return tsStr;
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            // Format as hh:mm:ss.sss
            return `${hours.toString().padStart(2, '0')}:` +
                   `${minutes.toString().padStart(2, '0')}:` +
                   `${secs.toFixed(3).padStart(6, '0')}`;
        }

        function formatSource(src) {
            // Match filename.lua#123
            const match = src.match(/^(.+\.lua)#(\d+)( *)$/);
            if (match) {
                return `<span class="source-filename">${match[1]}</span><span class="source-line">#${match[2]}</span>${match[3]}`;
            } else {
                return `<span class="source-other">${src}</span>${match[3]}`;
            }
        }

        function extractSource(src) {
            // Match filename.lua#123
            const match = src.match(/^(.+\.lua)#(\d+)( *)$/);
            if (match) {
                return match[1];
            } else {
                return src;
            }
        }

        function parseLuaValue(luaStr) {
            // Replace Lua booleans
            luaStr = luaStr.replace(/\btrue\b/g, 'true').replace(/\bfalse\b/g, 'false');
            // Replace Lua nil
            luaStr = luaStr.replace(/\bnil\b/g, 'null');
            // Replace single quotes with double quotes for strings
            luaStr = luaStr.replace(/'/g, '"');
            // Replace Lua table keys (a=1) with JSON keys ("a":1)
            luaStr = luaStr.replace(/([a-zA-Z_][a-zA-Z0-9_]*)\s*=/g, '"$1":');
            // Replace Lua arrays {1,2,3} with JSON arrays [1,2,3]
            // If keys are all numbers and sequential, treat as array
            // Otherwise, treat as object
            // For simplicity, convert all curly braces to brackets
            // This works for flat arrays/tables, not nested
            let isArray = /^\s*\{(\s*\d+\s*,?)*\s*\}\s*$/.test(luaStr);
            if (isArray) {
                luaStr = luaStr.replace(/^\s*\{/, '[').replace(/\}\s*$/, ']');
            } else {
                luaStr = luaStr.replace(/^\s*\{/, '{').replace(/\}\s*$/, '}');
            }
            // Now parse as JSON
            try {
                return JSON.parse(luaStr);
            } catch (e) {
                console.error("Failed to parse Lua:", luaStr, e);
                return null;
            }
        }

        function assignEdgeLabelOffsets(cy, marginStep = 12) {
            // Group edges by unordered node pair
            const edgeGroups = {};
            cy.edges().forEach(edge => {
                const src = edge.data('source');
                const tgt = edge.data('target');
                // Create an unordered key
                const key = [src, tgt].sort().join('|');
                if (!edgeGroups[key]) edgeGroups[key] = [];
                edgeGroups[key].push(edge);
            });

            // Add event listeners for hover
            cy.on('mouseover', 'edge', function(evt){
                evt.target.addClass('hover');
            });
            cy.on('mouseout', 'edge', function(evt){
                evt.target.removeClass('hover');
            });

            // Optionally, highlight on select as well
            cy.on('select', 'edge', function(evt){
                evt.target.addClass('hover');
            });
            cy.on('unselect', 'edge', function(evt){
                evt.target.removeClass('hover');
            });
        }
        
        let data = {};
        let permits = {};

        let _patrol_data = {};
        let path_cache = {};

        function procPossibleData(source, data)
        {
            switch (source) {
                case '_patrol.lua':
                    {
                        const [type] = data.split('|', 1);
                        switch (type) {
                            case 'AddRoute':
                                {
                                    const [id, origin, destination, path, weight, enabled] = data.split('|').slice(1);
                                    if (!_patrol_data[id]) {
                                        _patrol_data[id] = {};
                                    }
                                    if (!_patrol_data[id].routes) {
                                        _patrol_data[id].routes = {};
                                    }
                                    let route_id = origin + "\t" + destination + "\t" + path;
                                    _patrol_data[id].routes[route_id] = {
                                        origin: origin,
                                        destination: destination,
                                        path: path,
                                        weight: weight,
                                        enabled: enabled
                                    };
                                }
                                break;
                            case 'Location':
                                {
                                    const [id, location, position] = data.split('|').slice(1);
                                    let location_parsed = parseLuaValue(position);
                                    location_parsed.radius = location_parsed.y;
                                    delete location_parsed.y;
                                    if (!_patrol_data[id]) {
                                        _patrol_data[id] = {};
                                    }
                                    if (!_patrol_data[id].locations) {
                                        _patrol_data[id].locations = {};
                                    }
                                    _patrol_data[id].locations[location] = location_parsed;
                                }
                                break;
                            case 'PatrolEngines':
                                {
                                    const allowed = data.split('|').slice(1);
                                    for (const key in _patrol_data) {
                                        if (!allowed.includes(key)) {
                                            delete _patrol_data[key];
                                        }
                                    }
                                }
                                break;
                            case 'Path':
                                {
                                    const [name] = data.split('|').slice(1);
                                    function parsePathNodes(pathStr) {
                                        // Example: "Path|p_north_center|3027.090088,98541.703125|3058.080078,98451.398438|..."
                                        const parts = pathStr.split('|');
                                        // parts[0] = "Path", parts[1] = path name, parts[2...] = coordinates
                                        const coords = parts.slice(2);
                                        return coords.map(coord => {
                                            const [x, y] = coord.split(',').map(Number);
                                            return { x, y };
                                        });
                                    }
                                    path_cache[name] = parsePathNodes(data);
                                }
                                break;
                        }
                        document.getElementById('processed').innerText = JSON.stringify(_patrol_data, null, 2);

                        let elements = [];
                        for (const [PatrolId, data] of Object.entries(_patrol_data)) {
                            for (const [loc_id, loc_data] of Object.entries(data.locations || {})) {
                                elements.push({
                                    data: {
                                        id: loc_id,
                                        radius: Math.max(loc_data.radius * 2 + 5, 5),
                                        isLocation: true
                                    },
                                    position: {
                                        x: loc_data.x,
                                        y: -loc_data.z
                                    }
                                });
                            }
                            for (const [route_id, route_data] of Object.entries(data.routes || {})) {
                                let pth = path_cache[route_data.path];
                                if (pth) {
                                    let prev = route_data.origin;
                                    for (let i = 0; i < pth.length; i++) {
                                        elements.push({
                                            data: {
                                                id: route_data.path + "[" + i + "]",
                                                isWaypoint: true
                                            },
                                            position: {
                                                x: pth[i].x,
                                                y: -pth[i].y
                                            }
                                        });
                                        let newNode = {
                                            data: {
                                                id: route_id + '\t' + route_data.path + "[" + i + "]",
                                                source: prev,
                                                target: route_data.path + "[" + i + "]",
                                                label: route_data.path
                                            }
                                        }
                                        if (i == 0) {
                                            newNode.data.isTerminus = true;
                                        }
                                        elements.push(newNode);
                                        prev = route_data.path + "[" + i + "]";
                                    }
                                    elements.push({
                                        data: {
                                            id: route_id + '\t' + route_data.path + "[" + route_data.path.length + "]",
                                            source: prev,
                                            target: route_data.destination,
                                            label: route_data.path,
                                            isTerminus: true
                                        }
                                    });
                                } else {
                                    elements.push({
                                        data: {
                                            id: route_id,
                                            source: route_data.origin,
                                            target: route_data.destination,
                                            label: route_data.path
                                        }
                                    });
                                }
                            }
                        }

                        var cy = cytoscape({
                            container: document.getElementById('cy'),
                            elements: elements,
                            style: cyDarkStyle,
                            autoungrabify: true,
                            layout: { name: 'preset' }
                        });
                        assignEdgeLabelOffsets(cy);
                        //cy.add({ group: 'nodes', data: { id: 'marker1' }, position: { x: 300, y: 200 }, style: { 'background-color': '#219ebc' } });
                    }
                    break;
            }
        }

        window.onload = function () {
            const logDiv = document.getElementById('log');
            const logScrollParent = logDiv.parentElement; // .card-body

            const evtSource = new EventSource('/tail');
            evtSource.onmessage = function (event) {
                const [parent_type, time, source, type, msg] = splitKeepRemainder(event.data, '|', 5);
                if (parent_type == 'reset') {
                    logDiv.innerHTML = '';

                    data = {};
                    permits = {};

                    _patrol_data = {};
                    path_cache = {};
                } else {
                    const line = document.createElement('div');
                    const rawTime = time; // as received
                    const formattedTime = formatTimestamp(time);
                    line.innerHTML =
                        //`<span class="text-secondary" style="font-family:monospace; margin-right:0.5em;">${rawTime}</span>` +
                        `<span class="text-info" style="font-family:monospace; margin-right:0.5em;">${formattedTime}</span> ` +
                        formatSource(source) +
                        ansiToHtml(msg);
                    line.className = parent_type === 'error' ? 'text-danger' : 'text-light';
                    const isAtBottom = Math.abs(logScrollParent.scrollTop + logScrollParent.clientHeight - logScrollParent.scrollHeight) < 2;
                    logDiv.appendChild(line);
                    if (isAtBottom) {
                        logScrollParent.scrollTop = logScrollParent.scrollHeight;
                    }

                    procPossibleData(extractSource(source), msg);
                }
            };
            evtSource.onerror = function () {
                const line = document.createElement('div');
                line.textContent = 'Connection lost.';
                line.className = 'text-warning';
                logDiv.appendChild(line);
            };
        };
    </script>

    <script src="https://cdn.jsdelivr.net/npm/ansi_up@5.0.0/ansi_up.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridstack@12.3.3/dist/gridstack-all.min.js"></script>
    <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
</body>
</html>