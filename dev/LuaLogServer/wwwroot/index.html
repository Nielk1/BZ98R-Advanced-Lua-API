<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lua Web Log Server</title>
    <!-- Stylesheets -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@12.3.3/dist/gridstack.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    <style>
        body { background-color: #101112; }
        .card-body { background-color: #101112; }
        #log, #processed {
            white-space: pre;
            font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', 'Liberation Mono', 'Courier New', monospace;
            display: inline-block;
            min-width: 100%;
        }
        #log > div {
            padding-left: 0.5em;
            padding-right: 0.5em;
        }
        #log > div:nth-child(even) { background-color: #232425; }
        #log > div:nth-child(odd) { background-color: #181a1b; }
        #log > div:hover { background-color: #000000; }
        .source-filename { color: #8ecae6; }
        .source-line { color: #ffb703; }
        .source-other { color: #fb8500; }
        #map-container, #map {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #map-key {
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="grid-stack">
            <!-- Raw Log Window -->
            <div class="grid-stack-item" id="window-raw_log" gs-x="0" gs-y="0" gs-w="12" gs-h="6">
                <div class="grid-stack-item-content p-0">
                    <div class="card bg-dark text-light h-100 shadow border-secondary">
                        <div class="card-header d-flex align-items-center justify-content-between bg-secondary bg-gradient text-white py-2 px-3">
                            <span>
                                <span id="raw-log-timestamp2" class="text-light" style="font-family:monospace;white-space:pre;">      0.000</span>
                                <span id="raw-log-timestamp" class="text-info" style="font-family:monospace;">00:00:00.000</span>
                                Raw Log
                            </span>
                            <div>
                                <button type="button" class="btn btn-sm btn-light me-1" title="Maximize"><i class="bi-arrows-fullscreen"></i></button>
                                <button type="button" class="btn btn-sm btn-danger" title="Minimize"><i class="bi bi-dash"></i></button>
                            </div>
                        </div>
                        <div class="card-body p-0" style="overflow:scroll;">
                            <div id="log"></div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Map Window (Konva will be added here) -->
            <div class="grid-stack-item" id="window-map" gs-x="0" gs-y="6" gs-w="6" gs-h="8">
                <div class="grid-stack-item-content p-0">
                    <div class="card bg-dark text-light h-100 shadow border-secondary">
                        <div class="card-header d-flex align-items-center justify-content-between bg-secondary bg-gradient text-white py-2 px-3">
                            <span>Map</span>
                            <div>
                                <button type="button" class="btn btn-sm btn-light me-1" title="Maximize"><i class="bi-arrows-fullscreen"></i></button>
                                <button type="button" class="btn btn-sm btn-danger" title="Minimize"><i class="bi bi-dash"></i></button>
                            </div>
                        </div>
                        <div class="card-body p-0" style="overflow:hidden;">
                            <div id="map-container" style="position:relative; width:100%; height:100%;">
                                <div id="map" style="width:100%; height:100%;"></div>
                                <div id="map-key" style="position:absolute; top:10px; right:10px; background:#232425cc; color:#fff; padding:8px; border-radius:6px; z-index:10; max-height:200px; overflow-y:auto;">
                                    <strong>Map Key</strong>
                                    <div id="map-key-list"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Processed Data/Test Window -->
            <div class="grid-stack-item" id="window-test" gs-x="6" gs-y="0" gs-w="6" gs-h="8">
                <div class="grid-stack-item-content p-0">
                    <div class="card bg-dark text-light h-100 shadow border-secondary">
                        <div class="card-header d-flex align-items-center justify-content-between bg-secondary bg-gradient text-white py-2 px-3">
                            <span>Test</span>
                            <div>
                                <button type="button" class="btn btn-sm btn-light me-1" title="Maximize"><i class="bi-arrows-fullscreen"></i></button>
                                <button type="button" class="btn btn-sm btn-danger" title="Minimize"><i class="bi bi-dash"></i></button>
                            </div>
                        </div>
                        <div class="card-body p-2" style="overflow:scroll;">
                            <div id="processed"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Utility Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/ansi_up@5.0.0/ansi_up.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridstack@12.3.3/dist/gridstack-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/konva@9.2.0/konva.min.js"></script>

    <script>
        // ------------------- Utility Functions -------------------
        function ansiToHtml(text) {
            const ansi_up = new AnsiUp();
            return ansi_up.ansi_to_html(text);
        }
        function stripAnsi(text) {
            return text.replace(/\x1b\[[0-9;]*m/g, '');
        }
        function splitKeepRemainder(str, delimiter, count) {
            const parts = str.split(delimiter);
            if (parts.length <= count) return parts;
            const result = parts.slice(0, count - 1);
            result.push(parts.slice(count - 1).join(delimiter));
            return result;
        }
        function formatTimestamp(tsStr) {
            // Remove leading spaces and parse as float
            const seconds = parseFloat(tsStr.trim());
            if (isNaN(seconds)) return tsStr;
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            // Format as hh:mm:ss.sss
            return `${hours.toString().padStart(2, '0')}:` +
                   `${minutes.toString().padStart(2, '0')}:` +
                   `${secs.toFixed(3).padStart(6, '0')}`;
        }
        function formatSource(src) {
            // Match filename.lua#123
            const match = src.match(/^(.+\.lua)#(\d+)( *)$/);
            if (match) {
                return `<span class="source-filename">${match[1]}</span><span class="source-line">#${match[2]}</span>${match[3]}`;
            } else {
                return `<span class="source-other">${src}</span>${match[3]}`;
            }
        }
        function extractSource(src) {
            // Match filename.lua#123
            const match = src.match(/^(.+\.lua)#(\d+)( *)$/);
            if (match) {
                return match[1];
            } else {
                return src;
            }
        }
        function parseLuaValue(luaStr) {
            // Replace Lua booleans
            luaStr = luaStr.replace(/\btrue\b/g, 'true').replace(/\bfalse\b/g, 'false');

            // Replace Lua nil
            luaStr = luaStr.replace(/\bnil\b/g, 'null');

            // Replace single quotes with double quotes for strings
            luaStr = luaStr.replace(/'/g, '"');

            // Replace Lua ["string"] keys with JSON keys
            luaStr = luaStr.replace(/\[\s*"([^"]+)"\s*\]\s*=/g, '"$1":');
    
            // Replace Lua table keys (a=1) with JSON keys ("a":1)
            luaStr = luaStr.replace(/([a-zA-Z_][a-zA-Z0-9_]*)\s*=/g, '"$1":');

            // Replace invalid numbers (e.g., N123, H361) with quoted strings
            luaStr = luaStr.replace(/([:=]\s*)H(\d+)/g, '$1"HANDLE:$2"');

            // Replace Lua arrays {1,2,3} with JSON arrays [1,2,3]
            // If keys are all numbers and sequential, treat as array
            // Otherwise, treat as object
            // For simplicity, convert all curly braces to brackets
            // This works for flat arrays/tables, not nested
            let isArray = /^\s*\{(\s*\d+\s*,?)*\s*\}\s*$/.test(luaStr);
            if (isArray) {
                luaStr = luaStr.replace(/^\s*\{/, '[').replace(/\}\s*$/, ']');
            } else {
                luaStr = luaStr.replace(/^\s*\{/, '{').replace(/\}\s*$/, '}');
            }
            // Now parse as JSON
            try {
                return JSON.parse(luaStr);
            } catch (e) {
                console.error("Failed to parse Lua:", luaStr, e);
                return null;
            }
        }

        // ------------------- Data Stores -------------------
        let map_interacted = false;
        // automatic data management
        let main_data_store = new Map(); // map of string keys to weakrefs of objects
        let ttl_data_store = new Map(); // map of string keys to TTL (time-to-live) values and a strong reference
        let handle_to_gameobject = new Map(); // map handles to gameobject IDs just because they're useful for manual systems
        // manual data management
        let path_cache = {};
        let _patrol = {
            AddRoute: function(id, origin, destination, path, weight, enabled)
            {
                if (!this.Engines[id]) {
                    this.Engines[id] = {};
                }
                if (!this.Engines[id].routes) {
                    this.Engines[id].routes = {};
                }
                let route_id = origin + "\t" + destination + "\t" + path;
                this.Engines[id].routes[route_id] = {
                    origin: origin,
                    destination: destination,
                    path: path,
                    weight: weight,
                    enabled: enabled
                };
            },
            Location: function(id, location, location_data) {
                if (!this.Engines[id]) {
                    this.Engines[id] = {};
                }
                if (!this.Engines[id].locations) {
                    this.Engines[id].locations = {};
                }
                this.Engines[id].locations[location] = location_data;
            },
            PatrolEngines: function(ids) {
                // Remove patrol engines that are not in the existing list
                for (const key in this.Engines) {
                    if (!ids.includes(key)) {
                        delete this.Engines[key];
                    }
                }
            },
            PatrolObjects: function(engine, seqnos) {
                if (!this.Engines[engine]) {
                    this.Engines[engine] = {};
                }
                //let OldSet = this.Engines[engine].patrol_objects;
                this.Engines[engine].patrol_objects = new Set();
                for (const seqno of seqnos.split(',')) {
                    let seqNoInt = parseInt(seqno);
                    let GO_ID = handle_to_gameobject.get(seqNoInt);
                    if (GO_ID) {
                        let GOweak = main_data_store.get(GO_ID);
                        if (GOweak) {
                            let GO = GOweak.deref();
                            if (GO) {
                                this.Engines[engine].patrol_objects.add(GO);
                            }
                        }
                    }
                }
            },
            Engines: {},
        }

        function ClearAllData()
        {
            main_data_store.clear();
            ttl_data_store.clear();
            handle_to_gameobject.clear();

            _patrol.Engines = {};
            path_cache = {};

            Object.values(mapLayers).forEach(obj => {
                //if (obj.name !== 'tooltip') {
                if (obj.layer) {
                    obj.layer.destroyChildren();
                    obj.layer.batchDraw();
                }
            });

            map_interacted = false;
        }

        // ------------------- Konva Map Setup -------------------
        const mapDiv = document.getElementById('map');
        let stage = null;
        // Central registry for layers
        const mapLayers = {
            patrol_engines: { name: 'patrol_engines',                                                           key_order: 1, key: { id: 'toggle-patrol_engines', label: 'Patrol Engines', defaultChecked: true } },
            locations:      { name: 'locations'     , layer: new Konva.Layer({ id: 'locations' }), order:  1, key_order: 2, key: { id: 'toggle-locations'     , label: 'Locations'     , defaultChecked: true } },
            paths:          { name: 'paths'         , layer: new Konva.Layer({ id: 'paths'     }), order:  2, key_order: 4, key: { id: 'toggle-paths'    , label: 'Paths'         , defaultChecked: true } },
            tooltip:        { name: 'tooltip'       , layer: new Konva.Layer({ id: 'tooltip'   }), order: 99,                                                                                                   },
        };

        function createOrResizeKonvaStage() {
            const width = mapDiv.offsetWidth;
            const height = mapDiv.offsetHeight;

            if (!stage) {
                stage = new Konva.Stage({
                    container: 'map',
                    width: width,
                    height: height,
                    draggable: true
                });

                Object.values(mapLayers)
                    .filter(obj => obj.layer)
                    .sort((a, b) => a.order - b.order)
                    .forEach(obj => stage.add(obj.layer));

                attachKonvaWheelZoom(stage);
                stage.on('dragmove', function(evt) {
                    map_interacted = true;
                });
            } else {
                stage.width(width);
                stage.height(height);
                stage.batchDraw();
            }
        }

        // Mouse wheel zoom handler
        function attachKonvaWheelZoom(stage) {
            let scaleBy = 1.1;
            stage.on('wheel', (e) => {
                e.evt.preventDefault();
                const oldScale = stage.scaleX();
                const pointer = stage.getPointerPosition();
                const mousePointTo = {
                    x: (pointer.x - stage.x()) / oldScale,
                    y: (pointer.y - stage.y()) / oldScale,
                };

                let direction = e.evt.deltaY > 0 ? -1 : 1;
                let newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
                stage.scale({ x: newScale, y: newScale });

                // Keep mouse position stable
                const newPos = {
                    x: pointer.x - mousePointTo.x * newScale,
                    y: pointer.y - mousePointTo.y * newScale,
                };
                stage.position(newPos);
                stage.batchDraw();

                map_interacted = true;
            });
        }

        // Resize on window or grid resize
        window.addEventListener('resize', createOrResizeKonvaStage);
        document.addEventListener('gridstack-change', createOrResizeKonvaStage);

        // ------------------- Konva Map Drawing -------------------
        function ResetMapWindow() {
            if (!map_interacted) {
                fitStageToLayerContent(
                    stage,
                    Object.entries(mapLayers)
                        .filter(([name, obj]) => name !== 'tooltip' && obj.layer)
                        .sort((a, b) => a[1].order - b[1].order)
                        .map(([name, obj]) => obj.layer)
                );
            }
        }

        function fitStageToLayerContent(stage, layers, padding = 40) {
            // Find bounding box of all visible shapes in the given layers
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            layers.forEach(layer => {
                layer.getChildren().forEach(shape => {
                    if (!shape.visible()) return;
                    const box = shape.getClientRect({ relativeTo: stage });
                    minX = Math.min(minX, box.x);
                    minY = Math.min(minY, box.y);
                    maxX = Math.max(maxX, box.x + box.width);
                    maxY = Math.max(maxY, box.y + box.height);
                });
            });

            if (minX === Infinity) return; // No shapes

            // Calculate scale and position
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;
            const stageWidth = stage.width();
            const stageHeight = stage.height();

            const scaleX = (stageWidth - padding * 2) / contentWidth;
            const scaleY = (stageHeight - padding * 2) / contentHeight;
            const scale = Math.min(scaleX, scaleY, 1); // Don't zoom in past 1x

            stage.scale({ x: scale, y: scale });

            // Center the content
            const newX = padding - minX * scale;
            const newY = padding - minY * scale;
            stage.position({ x: newX, y: newY });

            stage.batchDraw();
        }
    
        function MapDraw_UpdatePatrolEngine(engineId) {
            let engines = null;
            if (engineId === true) {
                engines = Object.keys(_patrol.Engines);
            } else {
                engines = [engineId];
            }
            engines.forEach(engineId => {
                const engine = _patrol.Engines[engineId];
                if (!engine || !engine.locations) return;

                // Draw locations
                Object.entries(engine.locations).forEach(([locName, locData]) => {
                    let locationId = `Patrol_Location_${engineId}_${locName}`;

                    // Check if location already exists
                    let existing = mapLayers.locations.layer.findOne(`#${locationId}`);
                    if (!existing) {
                        // Create new location circle
                        const locationCircle = new Konva.Circle({
                            x: locData.x,
                            y: -locData.z,
                            radius: locData.radius,
                            //fill: '#06d6a0',
                            fill: null,
                            stroke: '#ffffff',
                            strokeWidth: 2,
                            dash: [6, 2],
                            id: locationId,
                            tooltip: `Location: ${locName}`,
                        });
                        mapLayers.locations.layer.add(locationCircle);
                    } else {
                        // Update existing location position
                        existing.position({ x: locData.x, y: -locData.z });
                        existing.radius(locData.radius + 4);
                    }
                });

                mapLayers.locations.layer.batchDraw();
            });

            ResetMapWindow();
        }
        function MapDraw_UpdatePaths(name, path_data) {
            // Clear previous route and waypoints for this path
            mapLayers.paths.layer.find(`#PathPoint_${name}`).forEach(node => node.destroy());
            mapLayers.paths.layer.find(`#Path_${name}_`).forEach(node => node.destroy());

            function shortenLineForArrow(x1, y1, x2, y2, q, r) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.sqrt(dx*dx + dy*dy);
                if (len === 0) return [x1, y1, x2, y2];
                const ux = dx / len;
                const uy = dy / len;
                // Only shorten the end point
                return [
                    //x1, y1,
                    x1 - ux * -q, y1 - uy * -q,
                    x2 - ux *  r, y2 - uy *  r
                ];
            }

            const r = 2; // waypoint radius
            const lineStroke = 2; // stroke width (also needed to back off arrow)

            // Draw route as a line
            let render_paths = true;
            let render_points = true;
            let render_box = false;
            switch(path_data.special)
            {
                case 1: // bounds
                    render_points = false;
                    render_paths = false;
                    render_box = true;
                    break;
                case 2: // spawn
                    // currently only can happen with 1 point so no rules needed
                    break;
                case 3: // area
                    render_points = false;
                    break;
                case 4: // cloud
                    render_paths = false;
                    break;
            }
            if (path_data.nodes.length < 2)
                render_paths = false;
            if (render_paths) {
                const points = [];
                for (const pt of path_data.nodes) {
                    points.push(pt.x, -pt.z);
                }
                switch(path_data.type)
                {
                    case 2: // loop
                        points.push(path_data.nodes[0].x, -path_data.nodes[0].z);
                    case 0: // one-way
                        // loop nodes
                        for (let i = 2; i < points.length; i += 2) {
                            const [x1, y1] = [points[i-2], points[i-1]];
                            const [x2, y2] = [points[i+0], points[i+1]];
                            const [sx, sy, ex, ey] = shortenLineForArrow(x1, y1, x2, y2, -lineStroke / 2, r + lineStroke);
                            const arrowPoints = [sx, sy, ex, ey];
                            const routeLine1 = new Konva.Arrow({
                                points: arrowPoints,
                                //stroke: '#8ecae6',
                                stroke: '#8ecae6',
                                strokeWidth: lineStroke,
                                //fill: '#8ecae6',
                                fill: '#8ecae6',
                                pointerLength: 4,
                                pointerWidth: 4,
                                lineCap: 'round',
                                id: `Path_${name}`,
                                tooltip: `Path: ${name}`
                            });
                            mapLayers.paths.layer.add(routeLine1);
                        }
                    break;
                    case 1: // round-trip
                        const routeLine2 = new Konva.Line({
                            points: points,
                            //stroke: '#8ecae6',
                            stroke: '#8ecae6',
                            strokeWidth: lineStroke,
                            lineCap: 'round',
                            id: `Path_${name}`,
                            tooltip: `Path: ${name}`
                        });
                        mapLayers.paths.layer.add(routeLine2);
                        break;
                }
            }

            if (render_points) {
                // Draw waypoints as small circles
                path_data.nodes.forEach((pt, idx) => {
                    const waypoint = new Konva.Circle({
                        x: pt.x,
                        y: -pt.z,
                        radius: r,
                        //fill: '#219ebc',
                        fill: '#fb8500',
                        hitStrokeWidth: 2, // makes the border easier to hit
                        id: `PathPoint_${name}[${idx}]`,
                        tooltip: `PathPoint: ${name}[${idx}]`
                    });
                    mapLayers.paths.layer.add(waypoint);
                });
            }

            mapLayers.paths.layer.batchDraw();

            ResetMapWindow();
        }

        // ------------------- Konva Layer Controls -------------------
        const mapKeyList = document.getElementById('map-key-list');
        Object.entries(mapLayers).sort((a, b) => a[1].key_order - b[1].key_order).forEach(([name, obj]) => {
            if (obj.key) {
                const label = document.createElement('label');
                label.style.display = 'block';
                if (obj.layer) {
                    label.innerHTML = `<input type="checkbox" id="${obj.key.id}" ${obj.key.defaultChecked ? 'checked' : ''}> ${obj.key.label}`;
                } else {
                    label.innerHTML = `<input type="checkbox" id="${obj.key.id}" disabled> ${obj.key.label}`;
                    label.children[0].indeterminate = true;
                }
                mapKeyList.appendChild(label);
            }
        });
        Object.entries(mapLayers).forEach(([name, obj]) => {
            if (obj.key && obj.layer) {
                document.getElementById(obj.key.id).addEventListener('change', function() {
                    obj.layer.visible(this.checked);
                    stage.batchDraw();
                });
            }
        });

        // ------------------- Konva Tooltip Logic -------------------
        Object.entries(mapLayers).forEach(([name, obj]) => {
            if (name === 'tooltip') return;
            if (!obj.layer) return;

            let currentTooltip = null;
            let currentShapeId = null;

            obj.layer.on('mouseover', function(evt) {
                const shape = evt.target;
                if (shape && shape.id()) {
                    stage.container().style.cursor = 'pointer';
                    currentShapeId = shape.id();

                    mapLayers.tooltip.layer.destroyChildren();

                    const pointer = stage.getPointerPosition();
                    const scale = stage.scaleX(); // assuming uniform scaling
                    const stagePos = stage.position();

                    const canvasX = (pointer.x - stagePos.x) / scale;
                    const canvasY = (pointer.y - stagePos.y) / scale;

                    // Create new tooltip
                    currentTooltip = new Konva.Label({
                        x: canvasX + 8 / scale,
                        y: canvasY - 8 / scale,
                        opacity: 0.85
                    });
                    currentTooltip.add(new Konva.Tag({ fill: '#232425' }));
                    //const tooltipText = shape.tooltip || shape.id();
                    const tooltipText = shape.attrs.tooltip || shape.id();
                    currentTooltip.add(new Konva.Text({
                        text: tooltipText,
                        fontSize: 16 / scale,
                        padding: 6 / scale,
                        fill: '#fff'
                    }));
                    currentTooltip.offsetY(currentTooltip.height());
                    mapLayers.tooltip.layer.add(currentTooltip);
                    mapLayers.tooltip.layer.batchDraw();
                    stage.batchDraw();
                }
            });

            obj.layer.on('mousemove', function(evt) {
                if (currentTooltip) {
                    const pointer = stage.getPointerPosition();
                    const scale = stage.scaleX();
                    const stagePos = stage.position();
                    const canvasX = (pointer.x - stagePos.x) / scale;
                    const canvasY = (pointer.y - stagePos.y) / scale;
                    currentTooltip.x(canvasX + 8 / scale);
                    currentTooltip.y(canvasY - 8 / scale);
                    currentTooltip.offsetY(currentTooltip.height());
                    const textNode = currentTooltip.findOne('Text');
                    textNode.fontSize(16 / scale);
                    textNode.padding(6 / scale);
                    mapLayers.tooltip.layer.batchDraw();
                }
            });

            obj.layer.on('wheel', (e) => {
                if (currentTooltip) {
                    const pointer = stage.getPointerPosition();
                    const scale = stage.scaleX();
                    const stagePos = stage.position();
                    const canvasX = (pointer.x - stagePos.x) / scale;
                    const canvasY = (pointer.y - stagePos.y) / scale;
                    currentTooltip.x(canvasX + 8 / scale);
                    currentTooltip.y(canvasY - 8 / scale);
                    currentTooltip.offsetY(currentTooltip.height());
                    const textNode = currentTooltip.findOne('Text');
                    textNode.fontSize(16 / scale);
                    textNode.padding(6 / scale);
                    mapLayers.tooltip.layer.batchDraw();
                }
            });

            obj.layer.on('mouseout', function(evt) {
                stage.container().style.cursor = '';
                mapLayers.tooltip.layer.destroyChildren();
                mapLayers.tooltip.layer.batchDraw();
                currentTooltip = null;
                currentShapeId = null;
            });
        });

        // ------------------- Data Management & Processing -------------------
        function MergeObjectIntoGlobalStore(id, obj) {
            const TTL_MS = 60000;
            const now = Date.now();

            // Ensure $id is set
            obj.$id = id;

            // Resolve $ref properties in obj
            for (const key in obj) {
                const val = obj[key];
                if (
                    val &&
                    typeof val === "object" &&
                    Object.keys(val).length === 1 &&
                    "$ref" in val &&
                    typeof val.$ref === "string"
                ) {
                    const refId = val.$ref;
                    let refObj = undefined;
                    if (main_data_store.has(refId)) {
                        const weakref = main_data_store.get(refId);
                        refObj = weakref.deref();
                    }
                    if (!refObj) {
                        // Create a placeholder object with $id
                        refObj = { $id: refId };
                        main_data_store.set(refId, new WeakRef(refObj));
                    }
                    obj[key] = refObj;
                }
            }

            // Merge logic as before
            if (ttl_data_store.has(id)) {
                const [target, _] = ttl_data_store.get(id);
                if (obj.$partial) {
                    for (const key in obj) {
                        if (key === '$partial') continue;
                        if (obj[key] === null) {
                            delete target[key];
                        } else {
                            target[key] = obj[key];
                        }
                    }
                } else {
                    for (const key in target) {
                        if (!(key in obj)) {
                            delete target[key];
                        }
                    }
                    for (const key in obj) {
                        if (key !== '$partial') {
                            target[key] = obj[key];
                        }
                    }
                }
                ttl_data_store.set(id, [target, now + TTL_MS]);
            } else if (main_data_store.has(id)) {
                const weakref = main_data_store.get(id);
                const target = weakref.deref();
                if (target) {
                    if (obj.$partial) {
                        for (const key in obj) {
                            if (key === '$partial') continue;
                            if (obj[key] === null) {
                                delete target[key];
                            } else {
                                target[key] = obj[key];
                            }
                        }
                    } else {
                        for (const key in target) {
                            if (!(key in obj)) {
                                delete target[key];
                            }
                        }
                        for (const key in obj) {
                            if (key !== '$partial') {
                                target[key] = obj[key];
                            }
                        }
                    }
                    ttl_data_store.set(id, [target, now + TTL_MS]);
                }
            } else {
                const target = {};
                if (obj.$partial) {
                    for (const key in obj) {
                        if (key === '$partial') continue;
                        if (obj[key] === null) {
                            delete target[key];
                        } else {
                            target[key] = obj[key];
                        }
                    }
                } else {
                    for (const key in obj) {
                        if (key !== '$partial') {
                            target[key] = obj[key];
                        }
                    }
                }
                ttl_data_store.set(id, [target, now + TTL_MS]);
                main_data_store.set(id, new WeakRef(target));
            }
        }

        setInterval(() => {
            const now = Date.now();
            for (const [id, [obj, ttl]] of ttl_data_store.entries()) {
                if (ttl < now) {
                    ttl_data_store.delete(id);
                }
            }
            console.log("TTL Cleanup done. Current TTL store size:", ttl_data_store.size);

            // Cleanup old entries in main_data_store
            for (const [id, weakref] of main_data_store.entries()) {
                if (weakref.deref() === undefined) {
                    main_data_store.delete(id);
                }
            }
            console.log("Main store cleanup done. Current main store size:", main_data_store.size);
        }, 10000);

        function processPatrolObjectBlock(lines) {
            // Temporary storage for parsed tables
            const tables = {};

            let last = null;
            let lastId = null;

            // Parse tables
            for (const line of lines) {
                if (line.startsWith('table|')) {
                    const [, tableId, luaStr] = line.match(/^table\|([A-F0-9]+)\|(.+)$/);
                    let obj = parseLuaValue(luaStr);

                    MergeObjectIntoGlobalStore(tableId, obj);

                    tables[tableId] = obj;
                    last = obj;
                    lastId = tableId;
                }
            }

            for (const [tableId, obj] of Object.entries(tables)) {
                if (obj.__type === "GameObject" && typeof obj.id === "string" && obj.id.startsWith("H")) {
                    handle_to_gameobject.set(parseInt(obj.id.split(':', 2)[1]), tableId); // Map handle to tableId
                }
            }

            return last;
        }

        let inDataBlock = null;
        let linesDataBlock = [];
        function procPossibleData(source, data)
        {
            let lastDataItem = null;
            let lastDataItemBlock = null;
            if (inDataBlock != null) {
                const [block_type, block_name] = data.split('|', 2);
                if (block_type == "END") {
                    if (block_name != inDataBlock) {
                        console.error("Mismatched END block:", block_name, "expected", inDataBlock);
                    }
                    lastDataItemBlock = inDataBlock;
                    inDataBlock = null;
                    linesDataBlock.push(data);

                    lastDataItem = processPatrolObjectBlock(linesDataBlock.slice(1, -1));
                    linesDataBlock = [];
                    // continue down
                } else {
                    linesDataBlock.push(data);
                    return true;
                }
            } else {
                const [block_type, block_name] = data.split('|', 2);
                if (block_type == "START") {
                    inDataBlock = block_name;
                    linesDataBlock.push(data);
                    return true;
                }
            }

            if (lastDataItem != null) {
                return true;
            } else {
                let used = false;
                switch (source) {
                    case '_paths.lua':
                        {
                            const [type] = data.split('|', 1);
                            switch (type) {
                                case 'Path':
                                    {
                                        const [name] = data.split('|').slice(1);
                                        function parsePathNodes(pathStr) {
                                            // Example: "Path|p_north_center|3027.090088,98541.703125|3058.080078,98451.398438|..."
                                            const parts = pathStr.split('|');
                                            // parts[0] = "Path", parts[1] = path name, parts[2] = path type, parts[3...] = coordinates
                                            const type = parseInt(parts[2]);
                                            const special = parseInt(parts[3]);
                                            const coords = parts.slice(4);
                                            return { type: type, special: special, nodes: coords.filter(coord => coord.includes(',')).map(coord => {
                                                const [x, y, z] = coord.split(',').map(Number);
                                                if (z == undefined) {
                                                    // process old log format with only x,z
                                                    return { x: x, y: y };
                                                }
                                                return { x, z }; // map y to z for 2D
                                            }) };
                                        }
                                        path_cache[name] = parsePathNodes(data);

                                        // Draw on Konva map
                                        MapDraw_UpdatePaths(name, path_cache[name]);

                                        used = true;
                                    }
                                    break;
                            }
                        }
                        break;
                    case '_patrol.lua':
                        {
                            const [type] = data.split('|', 1);
                            let UpdatedEngineId = null;
                            switch (type) {
                                case 'AddRoute':
                                    {
                                        const [id, origin, destination, path, weight, enabled] = data.split('|').slice(1);
                                        _patrol.AddRoute(id, origin, destination, path, weight, enabled);
                                        used = true;
                                        UpdatedEngineId = id;
                                    }
                                    break;
                                case 'Location':
                                    {
                                        const [id, location, position] = data.split('|').slice(1);
                                        let location_data = parseLuaValue(position);
                                        location_data.radius = location_data.y;
                                        delete location_data.y;

                                        _patrol.Location(id, location, location_data);
                                        used = true;
                                        UpdatedEngineId = id;
                                    }
                                    break;
                                case 'PatrolEngines':
                                    {
                                        const existing_engines = data.split('|').slice(1);
                                        _patrol.PatrolEngines(existing_engines);
                                        used = true;
                                        UpdatedEngineId = true;
                                    }
                                    break;
                                case 'PatrolObjects':
                                    {
                                        const [engine, seqnos] = data.split('|').slice(1);
                                        _patrol.PatrolObjects(engine, seqnos);
                                        used = true;
                                    }
                                    break;
                            }
                            if (UpdatedEngineId)
                                MapDraw_UpdatePatrolEngine(UpdatedEngineId);
                        }
                        break;
                }

                return used;
            }

            return false;
        }

        // ------------------- GridStack & UI Logic -------------------
        document.addEventListener('DOMContentLoaded', function () {
            const grid = GridStack.init({
                cellHeight: 70,
                handle: '.card-header'
            });

            // Initial sizing
            createOrResizeKonvaStage();

            // draw demo map
            //drawDemoMap();

            // Listen for GridStack item resize/move events
            grid.on('change', function(event, items) {
                // Check if the map window was affected
                if (items.some(item => item.el && item.el.id === 'window-map')) {
                    createOrResizeKonvaStage();
                }
            });

            // Minimize/maximize logic
            document.querySelectorAll('.btn[title="Minimize"]').forEach(btn => {
                btn.addEventListener('click', function () {
                    const gridItem = btn.closest('.grid-stack-item');
                    const card = gridItem.querySelector('.card');
                    const body = card.querySelector('.card-body');
                    const isMinimized = body.classList.toggle('d-none');
                    grid.update(gridItem, { h: isMinimized ? 1 : 4 });
                });
            });

            document.querySelectorAll('.btn[title="Maximize"]').forEach(btn => {
                btn.addEventListener('click', function () {
                    const gridItem = btn.closest('.grid-stack-item');
                    const card = gridItem.querySelector('.card');
                    const body = card.querySelector('.card-body');
                    body.classList.remove('d-none');
                    grid.update(gridItem, {
                        x: 0,
                        y: 0,
                        w: grid.getColumn(),
                        h: 8
                    });
                });
            });
        });

        // ------------------- Log Streaming & UI Update -------------------
        window.onload = function () {
            const logDiv = document.getElementById('log');
            const logScrollParent = logDiv.parentElement; // .card-body

            const evtSource = new EventSource('/tail');
            evtSource.onmessage = function (event) {
                const [parent_type, time, source, type, msg] = splitKeepRemainder(event.data, '|', 5);
                if (parent_type == 'reset') {
                    logDiv.innerHTML = '';

                    ClearAllData();
                } else {
                    const rawTime = time; // as received
                    const formattedTime = formatTimestamp(time);
                    document.getElementById('raw-log-timestamp').textContent = formattedTime;
                    document.getElementById('raw-log-timestamp2').textContent = rawTime;

                    if (!procPossibleData(extractSource(source), msg)) {
                        const line = document.createElement('div');
                        line.innerHTML =
                            //`<span class="text-secondary" style="font-family:monospace; margin-right:0.5em;">${rawTime}</span>` +
                            `<span class="text-info" style="font-family:monospace; margin-right:0.5em;">${formattedTime}</span> ` +
                            formatSource(source) +
                            ansiToHtml(msg);
                        line.className = parent_type === 'error' ? 'text-danger log-row' : 'text-light log-row';
                        const isAtBottom = Math.abs(logScrollParent.scrollTop + logScrollParent.clientHeight - logScrollParent.scrollHeight) < 2;
                        logDiv.appendChild(line);
                        if (isAtBottom) {
                            logScrollParent.scrollTop = logScrollParent.scrollHeight;
                        }
                    }
                }
            };
            evtSource.onerror = function () {
                const line = document.createElement('div');
                line.textContent = 'Connection lost.';
                line.className = 'text-warning';
                logDiv.appendChild(line);
            };
        };
    </script>
</body>
</html>